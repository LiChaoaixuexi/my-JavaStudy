HashMap 在 JDK 1.7 及之前与 JDK 1.8 及之后的版本中，底层实现和核心机制有显著差异，这些差异主要围绕性能优化、数据结构和并发问题展开。以下是具体区别：


### **一、底层数据结构**
| 版本         | 数据结构                          | 说明                                                                 |
|--------------|-----------------------------------|----------------------------------------------------------------------|
| JDK 1.7 及之前 | **数组 + 链表**                   | 所有哈希冲突的元素都以链表形式存储（拉链法）。                         |
| JDK 1.8 及之后 | **数组 + 链表 + 红黑树**          | 当链表长度超过阈值（默认 8）且数组容量 ≥ 64 时，链表转为红黑树；当节点数 ≤ 6 时，红黑树转回链表。 |

**核心目的**：JDK 1.8 引入红黑树是为了解决长链表查询效率低的问题（链表查询时间复杂度为 O(n)，红黑树为 O(log n)）。


### **二、链表插入方式**
| 版本         | 插入方式       | 说明                                                                 |
|--------------|----------------|----------------------------------------------------------------------|
| JDK 1.7 及之前 | **头插法**     | 新节点插入到链表头部（`newNode.next = table[i]; table[i] = newNode`）。 |
| JDK 1.8 及之后 | **尾插法**     | 新节点插入到链表尾部（需遍历链表找到尾节点后插入）。                   |

**为什么修改？**
- 头插法在多线程扩容时可能导致**链表环化**（扩容迁移元素时，两个线程同时操作可能使节点引用形成环，导致 get 时无限循环）。
- 尾插法避免了环化问题（但 HashMap 仍非线程安全，只是减少了一种并发风险）。


### **三、扩容时元素迁移逻辑**
| 版本         | 迁移逻辑                                                                 |
|--------------|--------------------------------------------------------------------------|
| JDK 1.7 及之前 | 扩容时重新计算所有元素的哈希值和索引，然后逐个迁移到新数组（需重新哈希）。 |
| JDK 1.8 及之后 | 利用数组长度为 2ⁿ 的特性，通过 `hash & oldCap` 判断元素是否需要迁移：<br> - 结果为 0：索引不变（`index`）；<br> - 结果非 0：索引变为 `index + oldCap`（无需重新计算哈希）。 |

**优势**：JDK 1.8 迁移时无需重新计算哈希，仅通过简单的与运算即可确定新索引，提升扩容效率。


### **四、哈希值计算方式**
| 版本         | 哈希值计算逻辑                                                                 |
|--------------|------------------------------------------------------------------------------|
| JDK 1.7 及之前 | 对 Key 的 `hashCode()` 进行多次扰动（4 次位运算 + 5 次异或），减少哈希冲突。       |
| JDK 1.8 及之后 | 仅做一次扰动：`(h = key.hashCode()) ^ (h >>> 16)`（高 16 位与低 16 位异或）。 |

**原因**：JDK 1.8 认为一次扰动已足够分散哈希值，且减少计算次数可提升效率（配合红黑树，即使冲突略多也能保证性能）。


### **五、扩容触发时机**
| 版本         | 扩容触发时机                                                                 |
|--------------|------------------------------------------------------------------------------|
| JDK 1.7 及之前 | 先判断是否需要扩容，再插入元素（若插入前 size ≥ threshold，则扩容）。           |
| JDK 1.8 及之后 | 先插入元素，再判断是否需要扩容（插入后 size > threshold，则扩容）。             |

**举例**：假设阈值为 12，JDK 1.7 中当 size=12 时插入元素会先扩容；JDK 1.8 中则在插入后 size=13 时才扩容。


### **六、其他细节差异**
1. **Entry 与 Node**：
    - JDK 1.7 中链表节点类为 `Entry<K,V>`，
    - JDK 1.8 中改为 `Node<K,V>`（实现 `Map.Entry` 接口），红黑树节点为 `TreeNode<K,V>`（继承 `Node`）。

2. **空数组初始化**：
    - JDK 1.7 中，`HashMap` 初始化时直接创建长度为 16 的数组（`DEFAULT_INITIAL_CAPACITY`）。
    - JDK 1.8 中，初始化时数组为 `null`，首次调用 `put` 时才通过 `resize()` 创建数组（延迟初始化，节省内存）。

3. **并发问题**：
    - 两者均非线程安全，但 JDK 1.7 的头插法在多线程扩容时可能导致**死循环**（环化链表），JDK 1.8 的尾插法避免了此问题，但仍可能出现数据覆盖等并发问题。


### **总结对比表**
| 特性               | JDK 1.7 及之前                  | JDK 1.8 及之后                  |
|--------------------|---------------------------------|---------------------------------|
| 数据结构           | 数组 + 链表                     | 数组 + 链表 + 红黑树            |
| 链表插入方式       | 头插法（可能环化）              | 尾插法（避免环化）              |
| 扩容迁移逻辑       | 重新计算哈希和索引              | 基于 `hash & oldCap` 快速迁移   |
| 哈希值计算         | 多次扰动（复杂）                | 一次扰动（简单高效）            |
| 扩容触发时机       | 插入前判断                      | 插入后判断                      |
| 节点类             | Entry                           | Node（普通节点）、TreeNode（树节点） |
| 数组初始化         | 构造时初始化                    | 首次 put 时延迟初始化           |


这些改进使 JDK 1.8 的 HashMap 在**查询效率**（红黑树）、**扩容性能**（快速迁移）和**并发安全性**（减少环化风险）上均优于 JDK 1.7 版本。