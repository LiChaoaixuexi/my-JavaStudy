### 一、什么是多线程？

* 进程：一个正在运行的程序（比如你的 Java 程序），是系统资源分配的基本单位。
* 线程：进程中的一个执行单元（“子任务”），一个进程可以包含多个线程，它们共享进程的内存资源（如堆内存），但有自己的栈内存。
* 多线程：多个线程同时（并发）执行，比如同时下载文件、同时处理多个用户请求。

### 二、为什么需要多线程？

* 提高效率：单线程执行多个任务时，必须 “做完一个再做下一个”（串行）；多线程可以 “同时做”（并发）。
* 响应更快：比如 GUI 程序，主线程处理界面，子线程处理后台计算，避免界面卡顿。

### 三、创建线程的 3 种方式（重点）

* Java 中创建线程主要有 3 种方式，前两种最基础。
  * 方式 1：继承 Thread 类
  * 步骤：继承Thread类 → 重写run()方法（线程执行的任务）→ 创建子类对象 → 调用start()方法（启动线程，JVM 会自动调用run()）。
  * 注意：
  * 必须调用start()而非run()：start()会让 JVM 创建新线程并执行run()；直接调用run()只是普通方法调用，不会启动新线程。
  * 缺点：Java 是单继承，继承Thread后不能再继承其他类，灵活性低。
* 方式 2：实现 Runnable 接口
  * 步骤：实现Runnable接口 → 重写run()方法（线程执行的任务）→ 创建实现类对象 → 创建Thread对象，将实现类对象作为参数传入 → 
  * 调用Thread对象的start()方法（启动线程，JVM 会自动调用run()）。
  * 注意：
  * 必须调用start()而非run()：start()会让 JVM 创建新线程并执行run()；直接调用run()只是普通方法调用，不会启动新线程。
  * 缺点：实现Runnable接口后，还需要创建Thread对象，略显繁琐。
* 方式 3：实现 Callable 接口（有返回值）
  * 前两种方式的run()无返回值，Callable可以返回结果，需要配合Future使用（了解即可，后续深入）。

### 四、线程的 5 种状态（生命周期）

* 线程从创建到销毁会经历以下状态（重点记转换关系）：
  * 新建（New）：创建线程对象后（未调用start()）。
  * 就绪（Runnable）：调用start()后，线程进入 “就绪队列”，等待 CPU 调度（抢到时间片就执行）。
  * 运行（Running）：线程获得 CPU 时间片，执行run()方法。
  * 阻塞 / 等待（Blocked/Waiting）：线程暂时停止执行（如等待锁、调用sleep()/wait()）。
  * 终止（Terminated）：run()执行完毕，或线程被中断。

### 五、线程常用方法（实战必用）

#### 1. start() vs run()

*    start()：启动线程，让线程进入就绪状态（JVM 会调用run()）。
*    run()：线程的任务体（直接调用只是普通方法，不会启动新线程）。

#### 2. sleep(long millis)（休眠）

*    让当前线程暂停执行millis毫秒（进入 “超时等待” 状态）。
*    不释放锁（如果持有锁，休眠时仍持有）。
*    静态方法：Thread.sleep(1000)（让当前线程睡 1 秒）。

#### 3. join()（等待线程结束）

*    让当前线程等待目标线程执行完毕后再继续。
*    场景：主线程需要子线程的结果时使用。

#### 4. synchronized（同步，解决线程安全）

*    当多个线程共享资源时（如卖票），可能出现 “超卖”“重复卖” 等问题（线程安全问题），
*    synchronized可保证同一时间只有一个线程执行同步代码。