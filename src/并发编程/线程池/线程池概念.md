   线程池是 Java 多线程编程中非常重要的组件，它通过预先创建一定数量的线程， 避免频繁创建和销毁线程带来的性能开销， 
同时能有效控制并发线程数量，防止资源耗尽。下面从基础概念到实战案例，帮你全面理解线程池。

### **一、为什么需要线程池？**

* 线程的创建和销毁是有成本的（涉及操作系统内核态操作），如果频繁创建线程（比如处理大量并发请求），会导致：
  * 性能损耗：频繁的线程创建 / 销毁占用 CPU 资源。
  * 资源耗尽：无限制创建线程可能导致内存溢出（OOM）。
* 线程池的作用：
  * 复用线程：线程创建后可重复使用，减少创建 / 销毁开销。
  * 控制并发数：限制最大线程数，避免资源耗尽。
  * 管理线程生命周期：统一管理线程的创建、执行、销毁，简化编程。

### **二、线程池核心参数（重点）**
* Java 通过ThreadPoolExecutor类实现线程池，其核心构造方法有 7 个参数，决定了线程池的行为：`
    * public ThreadPoolExecutor(
      * int corePoolSize,        // 核心线程数
      * int maximumPoolSize,     // 最大线程数
      * long keepAliveTime,      // 非核心线程空闲超时时间
      * TimeUnit unit,           // 超时时间单位
      * BlockingQueue<Runnable> workQueue, // 任务队列（存放等待执行的任务）
      * ThreadFactory threadFactory,       // 线程工厂（创建线程的方式）
      * RejectedExecutionHandler handler   // 拒绝策略（任务满时如何处理新任务）
    * )

#### **1.核心参数详解**
* **corePoolSize（核心线程数）：**
  * 线程池长期维持的线程数量（即使线程空闲也不会销毁，除非设置了allowCoreThreadTimeOut）。 新任务到来时，若核心线程未满，直接创建新线程执行任务。
* **maximumPoolSize（最大线程数）**：
  * 线程池允许创建的最大线程数（核心线程 + 非核心线程）。当核心线程满、任务队列也满时，会创建非核心线程执行任务，直到达到最大线程数。
* **keepAliveTime + unit（空闲超时时间）：**
  * 非核心线程空闲超过该时间后，会被销毁（释放资源）。可通过allowCoreThreadTimeOut(true)让核心线程也遵守该规则。
* **workQueue（任务队列）：**
  * 用于存放暂时无法执行的任务（核心线程满时）。
  * 常见队列类型：
    * ArrayBlockingQueue 和LinkedBlockingQueue 常用于典型的生产者-消费者场景。例如:任务处理系统中,生产者生成任务,消费者从队列中取出任务并执行。
    * PriorityBlockingQueue更适合处理带有优先级的任务场景,如任务调度系统。
    * DelayQueue适用于需要延迟处理的任务,例如:缓存失效策略、定时任务调度等。
    * SynchronousQueue 适合在线程间直接传递数据,而不希望数据被存储在队列中。例如:交接模式中使用 SynchronousQueue来传递任务。
* **threadFactory（线程工厂）：**
  * 自定义线程的创建方式（如设置线程名称、优先级、是否为守护线程等）。
* **handler（拒绝策略）：**
  * 当线程池满（最大线程数 + 任务队列都满）时，对新任务的处理策略。
  * 内置 4 种策略：
    *    AbortPolicy（默认，抛异常策略）： 直接抛RejectedExecutionException异常。
    *    CallerRunsPolicy（调用者运行策略）： 让提交任务的线程（如主线程）自己执行任务。
    *    DiscardPolicy（丢弃策略）： 直接丢弃新任务，不抛异常。
    *    DiscardOldestPolicy（丢弃最旧任务策略）： 丢弃任务队列中最旧的任务，再尝试提交新任务。

### **三、线程池执行流程（核心逻辑）**

* 当一个新任务提交到线程池时，执行步骤如下：
  * 判断核心线程池是否已满？
  * 未满：创建核心线程执行任务。
* 已满：进入步骤 2。
  * 判断任务队列是否已满？
  * 未满：将任务放入队列等待。
* 已满：进入步骤 3。
  * 判断线程数是否达到最大线程数？
  * 未达到：创建非核心线程执行任务。
  * 已达到：执行拒绝策略。

* 新任务 → 核心线程未满？→ 新建核心线程执行  
* ↓  是
* 任务队列未满？→ 放入队列等待  
* ↓  是
* 未达最大线程数？→ 新建非核心线程执行  
* ↓  是
* → 执行拒绝策略

### **四、Java 内置的 4 种常用线程池（Executors 工具类）**

* Java 提供Executors工具类，快速创建几种常用线程池（基于ThreadPoolExecutor封装），但实际开发中不推荐使用（可能导致 OOM，见后文说明），了解即可。

#### **1.FixedThreadPool（固定线程数）**
* java
`  ExecutorService fixedPool = Executors.newFixedThreadPool(5);
  // 核心线程数=最大线程数=5，任务队列是无界LinkedBlockingQueue`
* 适用：任务数量稳定，需要控制并发数的场景。

#### **2.CachedThreadPool（可缓存线程池）**
* java
` ExecutorService cachedPool = Executors.newCachedThreadPool();
  // 核心线程数=0，最大线程数=Integer.MAX_VALUE，空闲超时60秒，队列是SynchronousQueue`
* 适用：短期、轻量任务（如临时处理大量请求，线程可自动回收）。

#### **3.SingleThreadExecutor（单线程池）**
* java
`ExecutorService singlePool = Executors.newSingleThreadExecutor();
// 核心线程数=最大线程数=1，任务队列无界，所有任务串行执行`
* 适用：需要任务按顺序执行的场景（如日志打印）。

#### **4.ScheduledThreadPool（定时任务线程池）**
* java
`ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(3);
// 可定时或周期性执行任务（如定时备份数据），`

### **五、为什么不推荐 Executors？（阿里开发手册规范）**

* FixedThreadPool和SingleThreadExecutor使用无界队列（LinkedBlockingQueue），当任务过多时，队列会无限增长，导致 OOM。
* CachedThreadPool的最大线程数是 Integer.MAX_VALUE，可能创建大量线程，导致 OOM。
* 正确做法：直接使用ThreadPoolExecutor，手动指定核心参数（尤其是队列容量和最大线程数），避免资源耗尽。